from matplotlib import pyplot as plt
from argparse import ArgumentParser
import numpy as np
import json
import os


def main():

    # parser = ArgumentParser()

    # parser.add_argument('client_filename',help='json file generated by the client application to be visualized.')
    # parser.add_argument('prometheus_filename',help='json file downloaded from prometheus to be visualized')
    # parser.add_argument('-g', action="store_true")

    # args = parser.parse_args()


    for file in filter(lambda x: "prometheus" not in x, os.listdir("data/presentation")):
        with open(f'data/presentation/{file}') as f:
            c_data = json.load(f)
        with open(f'data/presentation/prometheus-{file}') as f:
            p_data = json.load(f)


        c_data, client_start_time = list(filter(lambda x: x['finished'],c_data['data'])), p_data['start_time']
        p_data, prometheus_start_time = p_data['data'], p_data['start_time']

        assert client_start_time == prometheus_start_time, "The two files must have the same start time"

        c_data = clean_client_data(c_data)
        p_data = clean_server_data(p_data)

        fig, axes = plt.subplots(2)

        for ax in axes:
            ax.set_xlabel('Times (s)')

        title = ''
        if 'constant' in file:
            title += 'Slow Constat'
        elif 'sinusoidal' in file:
            title += 'Sinusoidal'
        elif 'spikes' in file:
            title += 'Spiking'

        title += ' Load with '

        if '12-pods' in file:
            title += 'Twelve Pods Provisioned'
        elif '8-pods' in file:
            title += 'Eight Pods Provisioned'
        elif 'autoscaling':
            title += 'Autoscaling'



        
        axes[0].set_title(title)
        axes[0].set_ylabel('Requests per Second and Time (s)')
        axes[0].plot(c_data['time'], c_data['rps'], label='RPS')
        axes[0].plot(c_data['time'], c_data['ttft'], label='TTFT',color='orange')
        axes[0].scatter(*get_ttft_dots(c_data), color='orange')
        

        ax01 = axes[0].twinx()
        ax01.set_ylabel('# Active Pods', color = 'green')
        ax01.plot(p_data['time'], p_data['num_pods'], label='# Active Pods', color = 'green')
        ax01.tick_params(axis='y', labelcolor='green')
        
        axes[0].legend()

        axes[1].set_ylabel('Gigabytes', color='red')
        axes[1].plot(p_data['time'], p_data['memory_gb'], label='Memory', color = 'red')
        axes[1].tick_params(axis='y', labelcolor='red')

        ax11 = axes[1].twinx()
        ax11.set_ylabel('Tokens per Second (TPS)', color='purple')
        ax11.plot(c_data['time'], np.array(c_data['cps']) / 6, label='TPS', color='purple')
        ax11.tick_params(axis='y', labelcolor='purple')

        fig.tight_layout()
        plt.show()


def dict_to_vec(dict, key):
    return [d[key] for d in dict]



def clean_server_data(data):
    new_data = {
        'time': [],
        'num_pods': [],
        'cpu_seconds': [],
        'memory_gb': []
    }

    for time, num_pods, cpu_seconds, memory_bytes in data:
        new_data['time'].append(time)
        new_data['num_pods'].append(num_pods)
        new_data['cpu_seconds'].append(cpu_seconds)
        new_data['memory_gb'].append(memory_bytes/2**30)

    new_data['num_pods'] = new_data['num_pods'][2:-18]

    for field in new_data:
        if field == 'num_pods':
            continue
        new_data[field] = new_data[field][:-20]

    return new_data




def clean_client_data(data, dt = 10):
    start = data[0]['request_time']
    end = data[-1]['request_time']

    new_data = {
        'time': [],
        'rps': [],
        'cps': [],
        'ttft': [],
        'time_to_finish': []
    }
    i = 0
    for s in np.arange(start, end, dt):
        e = s + dt

        num_requests = 0
        num_chars = 0
        sum_ttft = 0
        sum_time_to_finish = 0
        while (i < len(data) and data[i]['request_time'] < e):
            num_requests += 1
            num_chars += data[i]['num_chars']
            sum_ttft += data[i]['ttft']
            sum_time_to_finish += data[i]['finish_time'] - data[i]['request_time']
            i += 1

        new_data['time'].append(s)
        new_data['rps'].append(num_requests/dt)
        new_data['cps'].append(num_chars/dt)
        new_data['ttft'].append(sum_ttft/num_requests if num_requests != 0 else None)
        new_data['time_to_finish'].append(sum_time_to_finish/num_requests if num_requests != 0 else None)

    return new_data



def get_ttft_dots(clean_data):
    times = []
    ttfts = []
    for time, pre_ttft, ttft, post_ttft in zip(clean_data['time'], clean_data['ttft'][0:], clean_data['ttft'][1:], clean_data['ttft'][2:]):
        if (not pre_ttft) and ttft and not post_ttft:
            times.append(time)
            ttfts.append(ttft)
    return times, ttfts

def convolve_median(arr, n=3):
    new_arr = np.ndarray(shape=len(arr))
    for i in range(len(arr)):

        start = max(i-n//2, 0)
        end = min(start + n, len(arr))
        new_arr[i] = np.median(arr[start:end])

    return new_arr




if __name__ == "__main__":
    main()